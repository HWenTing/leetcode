
####  JAVA基础知识问答
1.  **什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？**
	* Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。也就是class文件
	* Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。java源程序先通过javac编译成二进制class文件，class文件运行在jvm上，根据不同的机器硬件，jvm将同样的class文件转换成对应硬件的机器码。

2.  **JDK和JRE的区别是什么？**
	* JRE(Java Runtime Environment)  java运行时环境，包含了java虚拟机，java基础类库，是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
	* JDK(Java Development Kit) java开发工具包，包含了JRE，以及编译器javac，调试工具等，提供给程序员使用
	![Alt text](./jREJDK.png)
	
3. **static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？** 
	* static 是静态的意思，表示该方法的调用不需要通过类的实例来使用
	* Java中static方法不能被覆盖。因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
	* java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

4. **是否可以在static环境中访问非static变量？  **
	* 可以访问，但是不可以直接访问。需要有类的实例来访问。static变量属于类，随着类的加载而加载到静态方法区内存。当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。

5. **什么是自动拆装箱？**
	* Java支持的数据类型包括两种 一种是基本数据类型：byte short int long float double char boolean 另一种是引用数据类型，如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程
	* 常量池的关系，在创建一个-128～127之间的Integer时，它不会创建新对象
6. **重载和重写注意点**
	* 被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误（即静态方法不能被重写）；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配（Father a=new Son（）；若Father有个静态方法f（），其子类Son也有个相同静态方法f（），那么a.f（）是调用的Father的f（），也就是说引用a和Father的静态方法匹配）。
7. **什么是复制构造方法？**
	* 复制构造方法是c++里的概念，java里不存在复制构造方法。复制构造函数就是将本类的对象作为参数的构造函数，目的是用一个已经实例化的对象来初始化另一个对象，简单点说就是拷贝一个对象。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现。
8. **接口和抽象类的区别是什么？**
	* 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
	* 接口中所有的方法隐含的都是抽象的，抽象类中可以有非抽象方法
	* 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
	* Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
	* Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
	* 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象
	* java8后 接口中用default修饰的方法可以有函数体（可以实现）
9.  **进程和线程的区别是什么？**
	* 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
	* 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
	* .通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
	* 调度和切换：线程上下文切换比进程上下文切换要快得多。
10.  **创建线程有几种不同的方式？**
	* ①继承Thread类（真正意义上的线程类），是Runnable接口的实现。（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。（2）创建Thread子类的实例，即创建了线程对象。（3）调用线程对象的start()方法来启动该线程。
	* ②实现Runnable接口，并重写里面的run方法。（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例（注意 ，这里声明的是实现类，构造方法也是实现类的构造方法），并依此实例作为Thread构造方法的参数来创建Thread对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。
	* ③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。
	* ④实现callable接口，重写call方法，有返回值。
	* 继承于Thread类的线程类，可以直接调用start方法启动线程 ; 实现Runnable接口的类需要再次用Thread类包装后才能调用start方法。
	* Runnable接口有如下好处：①避免点继承的局限，一个类可以继承多个接口。②适合于资源的共享，多个线程可以共享一个runnable对象，所以非常适合多个相同线程来处理同一份资源的情况。但是也有缺点，thread子类获取线程时，用this.即可，而runnable接口则需要Thread.currentThread（）这个静态方法。
11. **Thread的常用方法**
	* start()：启动线程并执行相应的run()方法
	* run():子线程要执行的代码放入run()方法中
	* currentThread()：静态的，调取当前的线程
	* getName():获取此线程的名字
	* setName():设置此线程的名字
	* yield():调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源）
	* join():在A线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕,A线程再接着join()之后的代码执行
	* isAlive():判断当前线程是否还存活
	* sleep(long l):显式的让当前线程睡眠l毫秒  (只能捕获异常，因为父类run方法没有抛异常)
	* getPriority()：返回线程优先值
	* setPriority(int newPriority)：改变线程的优先级（非绝对，只是相对几率大些）
	* wait():当一个线程调用了object.wait()，那么它就会进入object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。
	* notify():当object对象调用了obj.notify()方法，就会从这个等待队列，随机选择一个线程将其唤醒。这里的选择是不公平的完全是随机的。
	* notifyAll()：它与notify()方法的功能基本一致，不同的是它在唤醒这个等待队列中的所有等待线程而不是随机选择一个
12.  **解释下线程的几种可用状态。**
	* new 新建一个线程对象
	* runnable 线程对象创建后，调用start方法。该状态的线程位于可运行线程池中，等待被线程调度选中，从而获得cpu的使用权
	* running runnable状态的线程获得了cpu的使用权，执行程序代码
	* block 阻塞状态是指线程因为某些原因放弃了cpu的使用权，暂停运行，直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：
		* 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。
		* 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
		* 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。
	*  死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 
![Alt text](./Thread.jpg)

13. **同步方法和同步代码块的区别是什么？**
	* 同步方法默认用this或者当前类class对象作为锁；
	* 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；
	* 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；

14. **在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？**
	* 监视器和锁在Java虚拟机中是一块使用的。在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.
	* 一旦方法或者代码块被 synchronized 修饰, 那么这个部分就放入了监视器的监视区域, 确保一次只能有一个线程执行该部分的代码, 线程在获取锁之前不允许执行该部分的代码
	*  JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。本质都是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器

15. **如何确保N个线程可以访问N个资源同时又不导致死锁？**
	* 多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁。使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

16. Java集合类框架的基本接口有哪些？
	* 两大类接口 Collection和Map。Collection下包含List、Set等，ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口。HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好
![Alt text](./1582794436856.png)

17. 为什么集合类没有实现Cloneable和Serializable接口？
	* 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。即，集合类框架中的接口没有实现Cloneable和Serializable接口，但是具体的实现类是实现了这些接口的，比如Arraylist
	* 实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本

18. 什么是迭代器(Iterator)？
	* 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。
	* Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的
remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

19. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
	* 快速失败： 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构（只对值进行修改不会抛出错误）进行了修改（增加、删除），则会抛出Concurrent Modification Exception。在 java.util 包的HashMap、ArrayList 这些集合类都是快速失败的。
		* 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
	* 安全失败： 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。java.util.concurrent 包下的类都是安全失败，比如：ConcurrentHashMap。
		*   原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

20. Java中的HashMap的工作原理是什么？
	* hashmap是一种键值对的数据结构，jdk1.8后用数组+链表+红黑树的方式实现。hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null。
	* 使用链地址法解决hash冲突
	* 1.8前是头插，但是并发场景下扩容1会出现循环链表，所以1.8后改为尾插，同时加入了红黑树，如果链表长度大于某个值（比如8），就转化为红黑树结构。在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。

21. HashMap和Hashtable有什么区别？
	* HashMap允许键和值是null，而Hashtable不允许键或者值是null。
	* Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境
	* HashMap是非线程安全的，HashTable是线程安全的。
	* 因为线程安全的问题，HashMap效率比HashTable的要高。
	*  一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。

22. Comparable和Comparator接口是干什么的？列出它们的区别。
	* Comparable是修改类内部来定义比较大小的方法。类实现了Comparable接口，然后重写了compareTo方法（这个方法可以看作比较器），这个类就拥有了内部比较器。
	* Comparator是在外部定义比较方法，应用于对象中。新定义一个类，类名随意，但这个类必须实现Comparator接口，重写compare方法，我们把这个称作外部比较器。
	* 使用Comparable方式比较时，我们将比较的规则写入了比较的类型中，其特点是高内聚。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是易维护，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。













#### 操作系统

* 操作系统的基本特征包括并发、共享、虚拟和异步

	* 并发指两个或多个事情在同一时间间隔内发生。操作系统的并发是通过分时得以实现的。并行需要硬件支持

	* 系统中的资源可供内存中多个并发执行的进程共同使用，分为互斥共享和同时访问
	
	* 虚拟是把一个物理的实体变为若干逻辑上的对应物，时分复用（处理器的分时共享） 空分复用（虚拟内存）
	
	* 异步 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底，而是走走停停，以不可预知的速度前进，这就是程序的异步性


* inode 包括以下信息：权限，拥有者群组，容量，建立或状态改变的时间，最近一次的读取时间，最近修改时间，定义文件特性的flag，该文件真正内容的指向

* 虚拟内存允许程序不将地址空间每一页都映射到物理内存，程序不需要全部调入内存就可以运行，这使得有限的内存可以运行大程序

* 假脱机技术 提高了I/O速度

* 处理死锁主要有四种方法： 鸵鸟策略（不处理），死锁检测与死锁恢复 ，死锁预防（破坏产生死锁的条件），死锁避免（银行家算法）

* 中断分为三类：外中断（i/o等），异常（地址越界、算术溢出等），陷入（用户程序的系统调用）

* 死锁的必要条件：互斥 等待和占有 不可抢占 循环等待

*  进程的状态 创建 就绪 运行 等待 终止


#### 计网操作系统数据库

*  ACID 原子性 一致性 隔离性 持久性

* 三次握手，是要保证客户端和服务器端都要确保各自和对方的接受和发送能力正常。






----------


#### 操作系统

* 操作系统的基本特征包括并发、共享、虚拟和异步

	* 并发指两个或多个事情在同一时间间隔内发生。操作系统的并发是通过分时得以实现的。并行需要硬件支持

	* 系统中的资源可供内存中多个并发执行的进程共同使用，分为互斥共享和同时访问
	
	* 虚拟是把一个物理的实体变为若干逻辑上的对应物，时分复用（处理器的分时共享） 空分复用（虚拟内存）
	
	* 异步 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底，而是走走停停，以不可预知的速度前进，这就是程序的异步性


* inode 包括以下信息：权限，拥有者群组，容量，建立或状态改变的时间，最近一次的读取时间，最近修改时间，定义文件特性的flag，该文件真正内容的指向

* 虚拟内存允许程序不将地址空间每一页都映射到物理内存，程序不需要全部调入内存就可以运行，这使得有限的内存可以运行大程序

* 假脱机技术 提高了I/O速度

* 处理死锁主要有四种方法： 鸵鸟策略（不处理），死锁检测与死锁恢复 ，死锁预防（破坏产生死锁的条件），死锁避免（银行家算法）

* 中断分为三类：外中断（i/o等），异常（地址越界、算术溢出等），陷入（用户程序的系统调用）

* 死锁的必要条件：互斥 等待和占有 不可抢占 循环等待

*  进程的状态 创建 就绪 运行 等待 终止

----------
#### 计网操作系统数据库

*  ACID 原子性 一致性 隔离性 持久性

* 三次握手，是要保证客户端和服务器端都要确保各自和对方的接受和发送能力正常。
