
####  JAVA基础知识问答
1.  **什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？**
	* Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。也就是class文件
	* Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。java源程序先通过javac编译成二进制class文件，class文件运行在jvm上，根据不同的机器硬件，jvm将同样的class文件转换成对应硬件的机器码。

2.  **JDK和JRE的区别是什么？**
	* JRE(Java Runtime Environment)  java运行时环境，包含了java虚拟机，java基础类库，是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
	* JDK(Java Development Kit) java开发工具包，包含了JRE，以及编译器javac，调试工具等，提供给程序员使用
	![Alt text](./jREJDK.png)
	
3. **static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？** 
	* static 是静态的意思，表示该方法的调用不需要通过类的实例来使用
	* Java中static方法不能被覆盖。因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
	* java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

4. **是否可以在static环境中访问非static变量？  **
	* 可以访问，但是不可以直接访问。需要有类的实例来访问。static变量属于类，随着类的加载而加载到静态方法区内存。当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。

5. **什么是自动拆装箱？**
	* Java支持的数据类型包括两种 一种是基本数据类型：byte short int long float double char boolean 另一种是引用数据类型，如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程
	* 常量池的关系，在创建一个-128～127之间的Integer时，它不会创建新对象
6. **重载和重写注意点**
	* 被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误（即静态方法不能被重写）；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配（Father a=new Son（）；若Father有个静态方法f（），其子类Son也有个相同静态方法f（），那么a.f（）是调用的Father的f（），也就是说引用a和Father的静态方法匹配）。
7. **什么是复制构造方法？**
	* 复制构造方法是c++里的概念，java里不存在复制构造方法。复制构造函数就是将本类的对象作为参数的构造函数，目的是用一个已经实例化的对象来初始化另一个对象，简单点说就是拷贝一个对象。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现。
8. **接口和抽象类的区别是什么？**
	* 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
	* 接口中所有的方法隐含的都是抽象的，抽象类中可以有非抽象方法
	* 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
	* Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
	* Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
	* 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象
	* java8后 接口中用default修饰的方法可以有函数体（可以实现）
9.  **进程和线程的区别是什么？**
	* 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
	* 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
	* .通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
	* 调度和切换：线程上下文切换比进程上下文切换要快得多。
10.  **创建线程有几种不同的方式？**
	* ①继承Thread类（真正意义上的线程类），是Runnable接口的实现。（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。（2）创建Thread子类的实例，即创建了线程对象。（3）调用线程对象的start()方法来启动该线程。
	* ②实现Runnable接口，并重写里面的run方法。（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例（注意 ，这里声明的是实现类，构造方法也是实现类的构造方法），并依此实例作为Thread构造方法的参数来创建Thread对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。
	* ③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。
	* ④实现callable接口，重写call方法，有返回值。
	* 继承于Thread类的线程类，可以直接调用start方法启动线程 ; 实现Runnable接口的类需要再次用Thread类包装后才能调用start方法。
	* Runnable接口有如下好处：①避免点继承的局限，一个类可以继承多个接口。②适合于资源的共享，多个线程可以共享一个runnable对象，所以非常适合多个相同线程来处理同一份资源的情况。但是也有缺点，thread子类获取线程时，用this.即可，而runnable接口则需要Thread.currentThread（）这个静态方法。
11. **Thread的常用方法**
	* start()：启动线程并执行相应的run()方法
	* run():子线程要执行的代码放入run()方法中
	* currentThread()：静态的，调取当前的线程
	* getName():获取此线程的名字
	* setName():设置此线程的名字
	* yield():调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源）
	* join():在A线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕,A线程再接着join()之后的代码执行
	* isAlive():判断当前线程是否还存活
	* sleep(long l):显式的让当前线程睡眠l毫秒  (只能捕获异常，因为父类run方法没有抛异常)
	* getPriority()：返回线程优先值
	* setPriority(int newPriority)：改变线程的优先级（非绝对，只是相对几率大些）
	* wait():当一个线程调用了object.wait()，那么它就会进入object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。
	* notify():当object对象调用了obj.notify()方法，就会从这个等待队列，随机选择一个线程将其唤醒。这里的选择是不公平的完全是随机的。
	* notifyAll()：它与notify()方法的功能基本一致，不同的是它在唤醒这个等待队列中的所有等待线程而不是随机选择一个


























#### 操作系统

* 操作系统的基本特征包括并发、共享、虚拟和异步

	* 并发指两个或多个事情在同一时间间隔内发生。操作系统的并发是通过分时得以实现的。并行需要硬件支持

	* 系统中的资源可供内存中多个并发执行的进程共同使用，分为互斥共享和同时访问
	
	* 虚拟是把一个物理的实体变为若干逻辑上的对应物，时分复用（处理器的分时共享） 空分复用（虚拟内存）
	
	* 异步 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底，而是走走停停，以不可预知的速度前进，这就是程序的异步性


* inode 包括以下信息：权限，拥有者群组，容量，建立或状态改变的时间，最近一次的读取时间，最近修改时间，定义文件特性的flag，该文件真正内容的指向

* 虚拟内存允许程序不将地址空间每一页都映射到物理内存，程序不需要全部调入内存就可以运行，这使得有限的内存可以运行大程序

* 假脱机技术 提高了I/O速度

* 处理死锁主要有四种方法： 鸵鸟策略（不处理），死锁检测与死锁恢复 ，死锁预防（破坏产生死锁的条件），死锁避免（银行家算法）

* 中断分为三类：外中断（i/o等），异常（地址越界、算术溢出等），陷入（用户程序的系统调用）

* 死锁的必要条件：互斥 等待和占有 不可抢占 循环等待

*  进程的状态 创建 就绪 运行 等待 终止


#### 计网操作系统数据库

*  ACID 原子性 一致性 隔离性 持久性

* 三次握手，是要保证客户端和服务器端都要确保各自和对方的接受和发送能力正常。






----------


#### 操作系统

* 操作系统的基本特征包括并发、共享、虚拟和异步

	* 并发指两个或多个事情在同一时间间隔内发生。操作系统的并发是通过分时得以实现的。并行需要硬件支持

	* 系统中的资源可供内存中多个并发执行的进程共同使用，分为互斥共享和同时访问
	
	* 虚拟是把一个物理的实体变为若干逻辑上的对应物，时分复用（处理器的分时共享） 空分复用（虚拟内存）
	
	* 异步 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底，而是走走停停，以不可预知的速度前进，这就是程序的异步性


* inode 包括以下信息：权限，拥有者群组，容量，建立或状态改变的时间，最近一次的读取时间，最近修改时间，定义文件特性的flag，该文件真正内容的指向

* 虚拟内存允许程序不将地址空间每一页都映射到物理内存，程序不需要全部调入内存就可以运行，这使得有限的内存可以运行大程序

* 假脱机技术 提高了I/O速度

* 处理死锁主要有四种方法： 鸵鸟策略（不处理），死锁检测与死锁恢复 ，死锁预防（破坏产生死锁的条件），死锁避免（银行家算法）

* 中断分为三类：外中断（i/o等），异常（地址越界、算术溢出等），陷入（用户程序的系统调用）

* 死锁的必要条件：互斥 等待和占有 不可抢占 循环等待

*  进程的状态 创建 就绪 运行 等待 终止

----------
#### 计网操作系统数据库

*  ACID 原子性 一致性 隔离性 持久性

* 三次握手，是要保证客户端和服务器端都要确保各自和对方的接受和发送能力正常。
