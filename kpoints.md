
####  JAVA基础知识问答
1.  **什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？**
	* Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。也就是class文件
	* Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。java源程序先通过javac编译成二进制class文件，class文件运行在jvm上，根据不同的机器硬件，jvm将同样的class文件转换成对应硬件的机器码。

2.  **JDK和JRE的区别是什么？**
	* JRE(Java Runtime Environment)  java运行时环境，包含了java虚拟机，java基础类库，是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
	* JDK(Java Development Kit) java开发工具包，包含了JRE，以及编译器javac，调试工具等，提供给程序员使用
	![Alt text](./jREJDK.png)
	
3. **static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？** 
	* static 是静态的意思，表示该方法的调用不需要通过类的实例来使用
	* Java中static方法不能被覆盖。因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
	* java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

4. **是否可以在static环境中访问非static变量？  **
	* 可以访问，但是不可以直接访问。需要有类的实例来访问。static变量属于类，随着类的加载而加载到静态方法区内存。当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。

5. **什么是自动拆装箱？**
	* Java支持的数据类型包括两种 一种是基本数据类型：byte short int long float double char boolean 另一种是引用数据类型，如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程
	* 常量池的关系，在创建一个-128～127之间的Integer时，它不会创建新对象
6. **重载和重写注意点**
	* 被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误（即静态方法不能被重写）；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配（Father a=new Son（）；若Father有个静态方法f（），其子类Son也有个相同静态方法f（），那么a.f（）是调用的Father的f（），也就是说引用a和Father的静态方法匹配）。
7. **什么是复制构造方法？**
	* 复制构造方法是c++里的概念，java里不存在复制构造方法。复制构造函数就是将本类的对象作为参数的构造函数，目的是用一个已经实例化的对象来初始化另一个对象，简单点说就是拷贝一个对象。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现。
8. **接口和抽象类的区别是什么？**
	* 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
	* 接口中所有的方法隐含的都是抽象的，抽象类中可以有非抽象方法
	* 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
	* Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
	* Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
	* 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象
	* java8后 接口中用default修饰的方法可以有函数体（可以实现）
9.  **进程和线程的区别是什么？**
	* 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
	* 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
	* .通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
	* 调度和切换：线程上下文切换比进程上下文切换要快得多。
10.  **创建线程有几种不同的方式？**
	* ①继承Thread类（真正意义上的线程类），是Runnable接口的实现。（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。（2）创建Thread子类的实例，即创建了线程对象。（3）调用线程对象的start()方法来启动该线程。
	* ②实现Runnable接口，并重写里面的run方法。（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例（注意 ，这里声明的是实现类，构造方法也是实现类的构造方法），并依此实例作为Thread构造方法的参数来创建Thread对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。
	* ③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。
	* ④实现callable接口，重写call方法，有返回值。
	* 继承于Thread类的线程类，可以直接调用start方法启动线程 ; 实现Runnable接口的类需要再次用Thread类包装后才能调用start方法。
	* Runnable接口有如下好处：①避免点继承的局限，一个类可以继承多个接口。②适合于资源的共享，多个线程可以共享一个runnable对象，所以非常适合多个相同线程来处理同一份资源的情况。但是也有缺点，thread子类获取线程时，用this.即可，而runnable接口则需要Thread.currentThread（）这个静态方法。
11. **Thread的常用方法**
	* start()：启动线程并执行相应的run()方法
	* run():子线程要执行的代码放入run()方法中
	* currentThread()：静态的，调取当前的线程
	* getName():获取此线程的名字
	* setName():设置此线程的名字
	* yield():调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源）
	* join():在A线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕,A线程再接着join()之后的代码执行
	* isAlive():判断当前线程是否还存活
	* sleep(long l):显式的让当前线程睡眠l毫秒  (只能捕获异常，因为父类run方法没有抛异常)
	* getPriority()：返回线程优先值
	* setPriority(int newPriority)：改变线程的优先级（非绝对，只是相对几率大些）
	* wait():当一个线程调用了object.wait()，那么它就会进入object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。
	* notify():当object对象调用了obj.notify()方法，就会从这个等待队列，随机选择一个线程将其唤醒。这里的选择是不公平的完全是随机的。
	* notifyAll()：它与notify()方法的功能基本一致，不同的是它在唤醒这个等待队列中的所有等待线程而不是随机选择一个
12.  **解释下线程的几种可用状态。**
	* new 新建一个线程对象
	* runnable 线程对象创建后，调用start方法。该状态的线程位于可运行线程池中，等待被线程调度选中，从而获得cpu的使用权
	* running runnable状态的线程获得了cpu的使用权，执行程序代码
	* block 阻塞状态是指线程因为某些原因放弃了cpu的使用权，暂停运行，直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：
		* 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。
		* 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
		* 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。
	*  死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 
![Alt text](./Thread.jpg)

13. **同步方法和同步代码块的区别是什么？**
	* 同步方法默认用this或者当前类class对象作为锁；
	* 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；
	* 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；

14. **在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？**
	* 监视器和锁在Java虚拟机中是一块使用的。在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.
	* 一旦方法或者代码块被 synchronized 修饰, 那么这个部分就放入了监视器的监视区域, 确保一次只能有一个线程执行该部分的代码, 线程在获取锁之前不允许执行该部分的代码
	*  JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。本质都是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器

15. **如何确保N个线程可以访问N个资源同时又不导致死锁？**
	* 多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁。使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

16. **Java集合类框架的基本接口有哪些？**
	* 两大类接口 Collection和Map。Collection下包含List、Set等，ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口。HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好
![Alt text](./1582794436856.png)

17. **为什么集合类没有实现Cloneable和Serializable接口？**
	* 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。即，集合类框架中的接口没有实现Cloneable和Serializable接口，但是具体的实现类是实现了这些接口的，比如Arraylist
	* 实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本

18. **什么是迭代器(Iterator)？**
	* 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。
	* Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的
remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

19. **快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？**
	* 快速失败： 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构（只对值进行修改不会抛出错误）进行了修改（增加、删除），则会抛出Concurrent Modification Exception。在 java.util 包的HashMap、ArrayList 这些集合类都是快速失败的。
		* 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
	* 安全失败： 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。java.util.concurrent 包下的类都是安全失败，比如：ConcurrentHashMap。
		*   原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

20. **Java中的HashMap的工作原理是什么？**
	* hashmap是一种键值对的数据结构，jdk1.8后用数组+链表+红黑树的方式实现。hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null。
	* 使用链地址法解决hash冲突
	* 1.8前是头插，但是并发场景下扩容1会出现循环链表，所以1.8后改为尾插，同时加入了红黑树，如果链表长度大于某个值（比如8），就转化为红黑树结构。在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。

21. **HashMap和Hashtable有什么区别？**
	* HashMap允许键和值是null，而Hashtable不允许键或者值是null。
	* Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境
	* HashMap是非线程安全的，HashTable是线程安全的。
	* 因为线程安全的问题，HashMap效率比HashTable的要高。
	*  一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。

22. **Comparable和Comparator接口是干什么的？列出它们的区别。**
	* Comparable是修改类内部来定义比较大小的方法。类实现了Comparable接口，然后重写了compareTo方法（这个方法可以看作比较器），这个类就拥有了内部比较器。
	* Comparator是在外部定义比较方法，应用于对象中。新定义一个类，类名随意，但这个类必须实现Comparator接口，重写compare方法，我们把这个称作外部比较器。
	* 使用Comparable方式比较时，我们将比较的规则写入了比较的类型中，其特点是高内聚。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是易维护，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。

23. **Enumeration接口和Iterator接口的区别有哪些？**
	* Enumeration 只有2个函数接口（hasMoreElements()，nextElement()）。 通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。占用内存少，速度快，但不是线程安全的
	* Iterator 只有3个函数接口（hasNext()，next()，remove()）。 Iterator除了能读取集合的数据之外，也能数据进行删除操作。 Iterator 支持 fail-fast 机制

24. **HashSet、TreeSet、LinkedHashSet对比？**
	* HashSet对速度进行了优化，提供了最快的查找速度，无特殊说明一般默认是用这个Set。放到HashSet中的元素要保证唯一，应该重写hashCode方法和equals方法，但是不能保证元素有序底层实现是哈希结构
	* TreeSet底层实现是红黑树(自平衡二叉树)，不但能保证元素唯一，还能元素保证有序，存放到TreeSet中的元素应该实现Comparable接口，重写compareTo方法，（或者实现comparator）否则会抛出ClassCastException。add()，remove()，contains()方法的时间复杂度是O(logn)。
	* LinkedHashSet，底层实现是哈希表和链表，保持了HashSet的速度，还能按照插入元素的顺序维持元素顺序

25. **finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？**
	* finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。但是GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。
	* 调用时机：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法（但不承诺等待其运行结束）。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。
	* finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。 

26. **如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？**
	* 不会立即释放对象占用的内存。 如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在 finalize方法中恢复引用 ）。只有确定了对象无法恢复引用的时候才会清除对象内存。

27. **Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?**
	* 栈：在函数中定义的 一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配 。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。
	* 堆：Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建。The heap is the runntime data area from which memory for all class instances and arrays is allocated。堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量
	* Java堆虚拟机中的共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation，java8废除）
		* 年轻代  ： 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 
		* 年老代 ：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
	* 永久代就是Java内存分配中的一块区域，表示的是持续使用的一些资源信息，比如class名、method等，这块区域里面的内存对GC的影响不大，并不是GC的首要考虑内容。在Java8中移除了永生代，取而代之是元空间(Metaspace)。String直接存放在堆中，类的元数据存储在meta space中，meta space占用外部内存，不占用堆内存。永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM没有这个东西.

28. **串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？**
	* Serial 收集器是历史悠久，最基本的收集器。它是一个单线程的收集器（说明：这里的单线程不仅仅是指收集器工作时使用一个CPU或者一条收集线程去收集，并且Serial工作时，必须暂停其他所有的工作线程，也就是“stop the world”，直到垃圾收集完成。）Serial是JVM运行在Client模式默认的新生代收集器。适合于单CPU、客户端级别。
	* 也叫做Parallel Scavenge 收集器，它的目标是达到一个可控制的吞吐量(throughput)，（说明：吞吐量就是CPU用于执行代码的时间和CPU总共消耗时间的比值，即：吞吐量 = 运行代码时间 / (运行代码时间 + 垃圾收集器工作时间)），JVM提供了两个参数以精确的控制吞吐量，-XX:MaxGCPauseMillis 最大收集停顿时间；-XX:GCTimeRatio 垃圾收集时间占总时间的比例。
	* 了解了他们各自的特性，那么他们之间的不同点就显而易见了，Serial收集器工作时 "stop the world",简单而高效。而throughput收集器更关注总体的吞吐量，收集效果和性能总是密切关联的。适合中等和大规模的应用程序。

29. **JVM的永久代中会发生垃圾回收么？**
	* 永生代也是可以回收的，条件是 :
		* 该类的实例都被回收。 
		* 加载该类的classLoader已经被回收 
		* 该类不能通过反射访问到其方法，而且该类的java.lang.class没有被引用 
	* 当满足这3个条件时，是可以回收，但回不回收还得看jvm。
![Alt text](./1583047442635.png)

30. **Java中的两种异常类型是什么？他们有什么区别？**
	* Throwable包含了错误(Error)和异常(Excetion两类).Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。非检查异常包括RuntimeException及其子类，一般都是由于程序的逻辑错误引起的，在编码的时候就可以避免，因此没必要进行检查。其他异常都属于检查异常。
![Alt text](./1583048476224.png)

31. **Java中Exception和Error有什么区别？**
	*	Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
	*	Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。	

32. **throw和throws有什么区别？**
	* Throw用于方法内部，Throws用于方法声明上
	* Throw后跟异常对象，Throws后跟异常类型
	* Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型

33. **final、finally、finalize()方法有什么区别？**
	* final是关键字，final可以修饰类、方法、属性。
		* 如果一个类被final修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是final类中的成员变量是可以改变的，要想final类中的成员变量的不可以改变，必须给成员变量添加final修饰。因此，一个类不能同时被final和abstract修饰，这两个关键字相互矛盾。
		* 如果final修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：final参数用来表示这个参数在这个函数内部不允许被修改。
		* final修饰属性，被final修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。final指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被final修饰的变量必须初始化，该变量其实就是常量。
	* finally作为异常处理的一部分，只能用在try/catch语句快中，finally代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。
	* finalize是Object类的一个方法。在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的finalize()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。

34. **什么是JDBC？**
	* JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。JDBC是允许用户在不同数据库之间做选择的一个抽象层，允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。
	* 通常情况下使用JDBC完成以下操作：
		* 同数据库建立连接；
		* 向数据库发送SQL语句；
		* 处理从数据库返回的结果；
	* JDBC具有下列优点：
		* JDBC与ODBC(Open Database Connectivity，即开放数据库互连）十分相似，便于软件开发人员理解；
		* JDBC使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；
		* JDBC支持多种关系型数据库，大大增加了软件的可移植性；
		* .JDBC API是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性；

35. **解释下驱动(Driver)在JDBC中的角色。**
	* 简单来说 JDBC是一套接口， 驱动是具体实现。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。
	* 在使用jdbc前，应该保证相应的Driver类已经被加载到jvm中，并且完成了类的初始化工作就行了






































----------
#### 操作系统

* 操作系统的基本特征包括并发、共享、虚拟和异步

	* 并发指两个或多个事情在同一时间间隔内发生。操作系统的并发是通过分时得以实现的。并行需要硬件支持

	* 系统中的资源可供内存中多个并发执行的进程共同使用，分为互斥共享和同时访问
	
	* 虚拟是把一个物理的实体变为若干逻辑上的对应物，时分复用（处理器的分时共享） 空分复用（虚拟内存）
	
	* 异步 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底，而是走走停停，以不可预知的速度前进，这就是程序的异步性


* inode 包括以下信息：权限，拥有者群组，容量，建立或状态改变的时间，最近一次的读取时间，最近修改时间，定义文件特性的flag，该文件真正内容的指向

* 虚拟内存允许程序不将地址空间每一页都映射到物理内存，程序不需要全部调入内存就可以运行，这使得有限的内存可以运行大程序

* 假脱机技术 提高了I/O速度

* 处理死锁主要有四种方法： 鸵鸟策略（不处理），死锁检测与死锁恢复 ，死锁预防（破坏产生死锁的条件），死锁避免（银行家算法）

* 中断分为三类：外中断（i/o等），异常（地址越界、算术溢出等），陷入（用户程序的系统调用）

* 死锁的必要条件：互斥 等待和占有 不可抢占 循环等待

*  进程的状态 创建 就绪 运行 等待 终止

----------
#### 计网操作系统数据库

*  ACID 原子性 一致性 隔离性 持久性

* 三次握手，是要保证客户端和服务器端都要确保各自和对方的接受和发送能力正常。


